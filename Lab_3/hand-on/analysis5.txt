這個實驗的程式碼是從Section 2-1改過來的，在這個實驗的Broker主要改動的地方是在在從Priority Queue取資料出來時，使用一個Thread負責把資料放到Thread Pool中空的Thread，並用Conditional Variable通知該Thread，讓Thread使用Writer傳送資料給Subscriber。
在Subscriber的地方，為避免實驗受到輸出I/O影響，每收到一次Topic，都會去計算他的Publisher-to-Subscriber Latency並記錄下來，並在Subscriber被Kill時將所有的Latency輸出，並在最後輸出總共收到幾個Topic，有幾個Topic Miss，以及計算出的Miss Rate。
這些結果在Parse_utils.sh的幫助下將被統整到各個Scheduling Policy在不同的CPU Utilization資料夾下的latency與latency_statistic文件內。

在設計Workload讓Workload分別可以對應到CPU Utilization的部份，我測量了很多次不同的Middle-rate topic amount，發現了一個問題。
我在測量到一半時發現CPU Utilization常常會卡在某一個%數，後來發現會這樣是因為Publisher傳送Topic的速率不夠快，有蠻多原因，不過最主要的原因是Publisher用來傳送Topic給Broker的Thread數量不足，
因為在Publisher這邊，我在Config裡面使用不同Topic name的數量來當作創建Thread的數量，因此我想到一個Tricky的辦法，
既可以維持三種Rate的Topic種類，又能讓Broker收到更多的Topic並提高CPU Utilization。這方法就是在Config中增加不同Topic Name但相同設置的Middle-rate topic，如此一來就可以維持三種Topic設置，又可以增加Broker收到Topic的速率。

做實驗所產生的數據，因為有些太過龐大(>100MB)，因此我選擇把他們壓縮起來，放到我的雲端硬碟，網址為https://drive.google.com/file/d/1scTltzqOSmzIKYLtPqb5SUwL0AcvX3iB/view?usp=sharing

CPU-Utilization Line Chart說明:
Y軸代表Average CPU Utilization，X軸代表在High, Middle, Low rate topic的Deadline，Period設置相同，且High, Low rate topic的Topic amount設置相同的情況下，不同的Middle rate topic的Topic amount。
觀察三種Scheduling Policy，發現三種Scheduling Policy在前三種Middle-rate topic amount表現出的CPU Utilization都大同小異。但後兩種Middle-rate topic amount表現出的CPU Utilization就有相當差距。
我個人認為1020 Middle-rate topic amount尚可採紀實驗結果，因為三種Scheduling Policy表現出的CPU Utilization相對接近，但1880 Middle-rate topic amount因為FIFO表現出的CPU Utilization與其餘兩種Scheduling Policies差距蠻大的，
因此在此次實驗中採紀1880 Middle-rate topic amount的結果是有失公允的，不過如果單純比較EDF與RM在100% CPU Utilization的結果倒是可以接受的。
我後來去查看了一下，發現FIFO之所以表現出的CPU Utilization會如此異常是因為當中的其中幾次(#7, #10)測試都在中途Crash了，而且Crash的時機點剛好都是我打開螢幕的一瞬間，如果下次有時間我應該會針對Crash的幾個測試做重測。

Latency Boxplot說明:
因為在Plotting Script中將畫出異常值的選項關閉，因此有時會出現99-th Percentile比Boxplot最高點(Max Latency)還要高的情況。
紅點代表99-th Percentile Publisher-to-Subscriber Latency，藍星代表Average Publisher-to-Subscriber Latency。
Y軸代表Publisher-to-Subscriber Latency，單位以Millisecond表示。X軸代表不同的Scheduling Policy。

Publisher-to-Subscriber Latency Under 20% CPU Utilization Box plot說明:
在這張圖中，可以看出FIFO無論在Average Latency或是99-th Percentile Latency的表現都比其餘兩個Scheduling Policies還要來的優秀。這可能代表FIFO在確保執行環境在低CPU Utilization會是個好的Scheduling Policy的選擇。

Publisher-to-Subscriber Latency Under 40% CPU Utilization Box plot說明:
在這張圖中，可以看出RM在Average Latency比其餘兩個Scheduling Policies還要來的優秀，而FIFO在99-th Percentile Latency比其餘兩個Scheduling Policies還要來的優秀。
不過我覺得整體上還是RM較為優秀，因為RM的99-th Percentile Latency雖非最優，但實際上他比最優的Scheduling Policy的99-th Percentile Latency相差不遠。

Publisher-to-Subscriber Latency Under 60% CPU Utilization Box plot說明:
在這張圖中，可以看出EDF的Average Latency是最優秀的，而FIFO在99-th Percentile Latency比其餘兩個Scheduling Policy還要來的優秀許多。
在較高的CPU Utilization的情況下，可以看出FIFO仍維持他一貫最優的99-th Percentile Latency，但他的Average Latency相較其他兩個Scheduling Policies來的高不少，
從這也可以推論FIFO是一個相對中規中矩的Scheduling Policy，雖然他的Average Latency相對其他兩個Scheduling Policies高上不少，但他優秀的99-th Percentile Latency顯示他在極端情況下仍可給出相對優良的Latency。
而EDF與RM雖然99-th Percentile Latency相近，不過從Average Latency可以看出，EDF對比RM給出的Average Latency好相當多，但從Box Plot可以看出，EDF在部份Topic的表現上比RM還要差一些，因為EDF的Box Plot在第75-th percentile Latency比RM還要高。

Publisher-to-Subscriber Latency Under 80% CPU Utilization Box plot說明:
在這張圖中，可以看出FIFO在Average Latency與99-th Percentile Latency比其餘兩個Scheduling Policy還要來的優秀。
在較高的CPU Utilization的情況下，可以看出FIFO仍維持他一貫最優的99-th Percentile Latency，而且他的Average Latency相較其他兩個Scheduling Policies好上不少。個人認為他的99-th Percentile Latency相比其餘兩個Scheduling Policies好上不少是正常的，但我個人認為另兩個Scheduling Policies的Average Latency比FIFO還要來的高是不太正常的，我想可能是被特定幾個100 Percentile Latency給拉高不少，不過這也顯現出FIFO的表現對於每種Rate的Topic表現都相對穩定許多。

Publisher-to-Subscriber Latency Under 100% CPU Utilization Box plot說明:
在這張圖中，可以看出RM的Average Latency比其餘兩個Scheduling Policies還要來的優秀相當多，而FIFO在99-th Percentile Latency比其餘兩個Scheduling Policy還要來的優秀相當多。
在較高的CPU Utilization的情況下，可以看出FIFO的99-th Percentile Latency仍保持最優，而另外兩個Scheduling Polices在這種高負載的情況下表現都相當優秀，這點可以從他們把Box Plot壓到比FIFO低很多為證，其中以RM的Average Latency為最優，不過他們共同的點是部份Topic的Latency會達到不可思議的高，這一點可以從99-th Percentile Latency看出，而這也是100% CPU使用率下必然導致的結果。
單就這張圖的結果可以論斷RM在高負載的情況下是相當優秀的，不過考量到CPU Utilization中顯示FIFO並無達到接近100%的數值，而另外兩個有達到，因此我只能使用這張圖呈現出EDF與RM結果來做比較。

我其實還有準備各個測項的Miss rate的資料放在各個Scheduling Policy with specific cpu utilization資料夾下(名為latency_statistic)，不過因為數據都是點，因此沒有畫出來。
在plotting中有一些檔名後綴為-2是我想完整呈現數據，所造出來的圖。

在跑實驗的過程中，有好幾次都在跑完隔天發現有重大問題，得再重跑一次，可以說是非常的麻煩，不過這次作業有讓我深刻感受到做實驗的有趣以及要花費的心力。 
